# Задание 2 Аллокатор

В xv6 реализован только страничный аллокатор — выделять объекты размером
меньше страницы неэффективно: на их хранение уйдет целая страница. Из-за этого, все
«маленькие» объекты — файловые дескрипторы, структуры процессов и так далее —
выделяются статически:

[`kernel/file.c:17-20`](./kernel/file.c#L17)

```c
struct {
    struct spinlock lock;
    struct file file[NFILE];
} ftable
```

Таким образом, количество файлов ограничено переменной `NFILE`. Сильно
увеличивать эту переменную нельзя — большая часть памяти уйдёт на работу
операционной системы. Наоборот, если `NFILE` слишком мало, система не сможет
поддерживать достаточное количество одновременно открытых файлов.
(`NFILE`, как и многие другие константы можно найти в файле
[`kernel/params.h`](./kernel/param.h))


Наша цель — избавиться от этого, заменить аллокатор памяти и
выделять файловые структуры динамически. Свой аллокатор
писать не потребуется — [buddy allocator](https://en.wikipedia.org/wiki/Buddy_memory_allocation)
уже написан. Для этого задания также заменен
[`kernel/kalloc.c`](./kernel/kalloc.c): там уже
инициализируются служебные структуры аллокатора, где
хранится информация о свободных и занятых блоках

## Часть 1. Использование аллокатора

Используйте для выделения файловых структур новый аллокатор
вместо статического массива. Для этого измените файл
[`kernel/file.c`](./kernel/file.c).


1. Теперь вам не нужен статический массив файловых структур
   — он находится в
   [`kernel/file.c:19`](./kernel/file.c#L19). При каждом
   вызове функции `filealloc` просто выделите место под файл
   с помощью `bd_malloc`.
2. Не забудьте освободить используемую память в функции
   `fileclose`.

- Нужен ли теперь `ff`?
- Нужна ли блокировка в `ftable.lock`? Зачем она вообще
  используется?

3. Чем заполнена область памяти, которую возвращает
   `bd_malloc`? Что было при использовании статического
   аллокатора?


После внесения правок в код запустите [`alloctest`](./user/alloctest.c). Должен пройти
первый тест:

```bash
$ alloctest
filetest: start
filetest: OK
...
```

Этот тест открывает больше, чем `NFILES` файлов и ожидает, что
они все откроются.

Если вы просто увеличите `NFILE`, тесты не пройдут. Вы можете изменить
`kernel/file.c` так, чтобы использовать не `NFILE`, а большую константу, но
задание не будет принято, несмотря на пройденные тесты.

Запустите usertests и убедитесь, что все тесты проходят.
Перед повторным запуском `usertests` вероятно вам понадобится
вернуть файловую систему в изначальное состояние: 

```bash
rm fs.img
make qemu
```

## Часть 2. Оптимизация аллокатора

`Buddy allocator` можно оптимизировать следующим образом: сейчас мы для
каждого блока храним два бита — флаги «блок занят» (`alloc`) и «блок
поделен на две части» (`split`). Фактически, флаг «блок занят» мы
используем только в одном месте — когда хотим понять, нужно ли
объединить соседние блоки при освобождении. Давайте попробуем здесь
сэкономить 1 бит: вместо флага «блок занят» будем хранить для пары
соседних блоков флаг «блок A занят xor блок B занят». Тогда флаг будет
установлен, когда занят ровно один из двух блоков, и снят, если оба
свободны или оба заняты. Когда мы занимаем или освобождаем блок,
достаточно просто инвертировать флаг. При этом, если при освобождении
блока бит изменился с 1 на 0, это означает, что до этого у нас из пары
был занят ровно один блок, а теперь оба блока свободны. И именно в этом
случае мы должны объединить блоки. 

Если xv6 управляет объемом памяти размером 128 МБ, то такая оптимизация
сохранит нам порядка 1 МБ памяти.

Примените эту оптимизацию для написанного аллокатора и проверьте, что
свободной памяти становится больше. Для этого измените файл
[`kernel/buddy.c`](./kernel/buddy.c).

1. Используйте `bd_print`, чтобы в любом месте увидеть состояние структур
   аллокатора. Обратите внимание, что если вы поменяете назначение
   массива `alloc`, то функция будет работать некорректно. Исправлять её
   необязательно, но это поможет вам отлаживать код.
2. Обратите внимание на то, как аллокатор инициализируется: он считает,
   что управляет объемом памяти, являющимся степенью двойки — немного
   большим, чем доступный объем памяти — однако, блок в начале (та
   часть, где хранятся служебные структуры) и блок в конце (который на
   самом деле недоступен) помечаются как выделенные. После выполнения
   этой части снова запустите `alloctest`. Должны пройти оба теста


```bash
$ alloctest
filetest: start
filetest: OK
memtest: start
memtest: OK
```

Второй тест проверяет, сколько памяти занимает ваш аллокатор: программа
выделяет всю доступную память и проверяет, что вы сэкономили достаточное
количество памяти.

Снова убедитесь, что все тесты из `usertests` проходят.

- - -

### Комментарии

Buddy (bd) аллокатор реализован очень примитивно, похоже на то, как это описано в
[википедии](https://en.wikipedia.org/wiki/Buddy_memory_allocation),
т.е. используется для более компактной упаковки памяти в виде блоков, а не в виде страниц.

**Buddy** — это блок, который связан с другим блоком и только с ним он может быть
объединен в блок большего размера. 

Структуры bd держатся на массиве двусвязных
списков со свободными блоками доступных размеров (`LEAF_SIZE` $\times 2^k$). Так
как блоков одного размера может быть занято много, но не больше, чем может
поместиться в `HEAP_SIZE`, будем хранить признаки того, занят ли данный блок
или нет, индексируя его среди других блоков того же размера (`struct
sz_info.alloc`). Таким же образом нужно хранить информацию, был ли блок разделен на 2
других buddy-блока (`struct sz_info.split`).

Следующий шаг — по'xor'ить отметки о занятости buddy-блоки, чтобы уменьшить размер памяти занимаемой массивом `alloc` _почти_ в 2 раза.

- - -

## Часть 3\*. Использование аллокатора

Примените buddy `allocator` для структур процессов, аналогично части 1.
Тесты на эту часть отсутствуют, оно проверяется преподавателем вручную.
Не забудьте проверить, что `usertests` работают. Требования к сдаче ЛР
преподавателю:

- Наличие отчета, который включает в себя ссылку на репозиторий, вывод о
  проделанной работе
- Готовность запустить тесты по просьбе преподавателя

- - -

- научиться пользоваться gdb (`gdb-multiarch` в контейнере)
- фиксим ошибки мультипоточности

```sh
init: starting sh
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2354
/* omitted */
$ ls
scause 0x000000000000000d
sepc=0x0000000080006248 stval=0x0000000000000041
panic: kerneltrap
```
- https://stackoverflow.com/questions/77235828/xv6-scheduling-kernel-panic

```diff
0000000080006228 <bit_invert>:

// Invert bit at position index in array which stands for xor'ed bits of pair
// blocks at (2 * index) and (2 * index + 1) positions
void bit_invert(char *array, int index) {
    80006228:	1141              	addi	sp,sp,-16
    8000622a:	e422             	sd	    s0,8(sp)
    8000622c:	0800               	addi	s0,sp,16
  char b = array[index / 8];
    8000622e:	41f5d79b          	sraiw	a5,a1,0x1f
    80006232:	01d7d79b          	srliw	a5,a5,0x1d
    80006236:	9dbd             	addw	a1,a1,a5
    80006238:	4035d71b          	sraiw	a4,a1,0x3
    8000623c:	953a             	add	    a0,a0,a4
  char m = (1 << (index % 8));
    8000623e:	899d             	andi	a1,a1,7
    80006240:	9d9d             	subw	a1,a1,a5
    80006242:	4785             	li	    a5,1
    80006244:	00b795bb          	sllw	a1,a5,a1
  array[index / 8] = (b ^ m);
+   80006248:	00054783          	lbu	    a5,0(a0)
    8000624c:	8dbd                xor	    a1,a1,a5
    8000624e:	00b50023          	sb	    a1,0(a0)
}
    80006252:	6422                ld	    s0,8(sp)
    80006254:	0141               	addi	sp,sp,16
    80006256:	8082            	ret

```

GDB показывает следующие регистры до выполнения `lbu a5,0(a0)` @ `0x80006248`.

```gdb
┌─Register group: general──────────────────────────────────────────────┐
│zero           0x0      0                                             │
│ra             0x8000656c       0x8000656c <bd_malloc+232>            │
│sp             0x8024ced0       0x8024ced0                            │
│gp             0x0      0x0                                           │
│tp             0x0      0x0                                           │
│t0             0x8000280e       2147493902                            │
│t1             0x800000000008021d       -9223372036854250979          │
│t2             0x0      0                                             │
│fp             0x8024cee0       0x8024cee0                            │
│s1             0x7      7                                             │
│a0             0x41     65                                            │
│a1             0x1      1                                             │
│a2             0x1      1                                             │
│a3             0x1      1                                             │
│a4             0x40     64                                            │
│a5             0x1      1                                             │
│a6             0x0      0                                             │
│a7             0x1      1                                             │
│s2             0x800089f0       2147518960                            │
│s3             0xe0     224                                           │
│s4             0x800089f8       2147518968                            │
│s5             0x8021c800       2149697536                            │
│s6             0x0      0                                             │
│s7             0x5      5                                             │
│s8             0x0      0                                             │
│s9             0x0      0                                             │
│s10            0x0      0                                             │
│s11            0x0      0                                             │
┌──────────────────────────────────────────────────────────────────────┐
│B+  0x80006228 <bit_invert>         addi    sp,sp,-16                 │
│    0x8000622a <bit_invert+2>       sd      s0,8(sp)                  │
│    0x8000622c <bit_invert+4>       addi    s0,sp,16                  │
│    0x8000622e <bit_invert+6>       sraiw   a5,a1,0x1f                │
│    0x80006232 <bit_invert+10>      srliw   a5,a5,0x1d                │
│    0x80006236 <bit_invert+14>      addw    a1,a1,a5                  │
│    0x80006238 <bit_invert+16>      sraiw   a4,a1,0x3                 │
│    0x8000623c <bit_invert+20>      add     a0,a0,a4                  │
│    0x8000623e <bit_invert+22>      andi    a1,a1,7                   │
│    0x80006240 <bit_invert+24>      subw    a1,a1,a5                  │
│    0x80006242 <bit_invert+26>      li      a5,1                      │
│    0x80006244 <bit_invert+28>      sllw    a1,a5,a1                  │
│  > 0x80006248 <bit_invert+32>      lbu     a5,0(a0)                  │
│    0x8000624c <bit_invert+36>      xor     a1,a1,a5                  │
│    0x8000624e <bit_invert+38>      sb      a1,0(a0)                  │
│    0x80006252 <bit_invert+42>      ld      s0,8(sp)                  │
│    0x80006254 <bit_invert+44>      addi    sp,sp,16                  │
│    0x80006256 <bit_invert+46>      ret                               │
│    0x80006258 <bd_print_vector>    addi    sp,sp,-80                 │
│    0x8000625a <bd_print_vector+2>  sd      ra,72(sp)                 │
│    0x8000625c <bd_print_vector+4>  sd      s0,64(sp)                 │
└──────────────────────────────────────────────────────────────────────┘
remote Thread 1.1 In: bit_invert                   L69   PC: 0x80006248
```
А уже после — лежит в каневе.

```gdb
┌─Register group: general──────────────────────────────────────────────┐
│zero           0x0      0                                             │
│ra             0x8000057c       0x8000057c <panic+62>                 │
│sp             0x8024cd80       0x8024cd80                            │
│gp             0x0      0x0                                           │
│tp             0x0      0x0                                           │
│t0             0x8000280e       2147493902                            │
│t1             0x800000000008021d       -9223372036854250979          │
│t2             0x0      0                                             │
│fp             0x8024cda0       0x8024cda0                            │
│s1             0x800083e0       2147517408                            │
│a0             0x0      0                                             │
│a1             0x80006248       2147508808                            │
│a2             0x41     65                                            │
│a3             0x1      1                                             │
│a4             0x8000857e       2147517822                            │
│a5             0x1      1                                             │
│a6             0x0      0                                             │
│a7             0x1      1                                             │
│s2             0x80006248       2147508808                            │
│s3             0xd      13                                            │
│s4             0x800089f8       2147518968                            │
│s5             0x8021c800       2149697536                            │
│s6             0x0      0                                             │
│s7             0x5      5                                             │
│s8             0x0      0                                             │
│s9             0x0      0                                             │
│s10            0x0      0                                             │
│s11            0x0      0                                             │
└──────────────────────────────────────────────────────────────────────┘
│    0x80000562 <panic+36>   mv      a0,s1                             │
│    0x80000564 <panic+38>   auipc   ra,0x0                            │
│    0x80000568 <panic+42>   jalr    36(ra)                            │
│    0x8000056c <panic+46>   auipc   a0,0x8                            │
│    0x80000570 <panic+50>   addi    a0,a0,-1220                       │
│    0x80000574 <panic+54>   auipc   ra,0x0                            │
│    0x80000578 <panic+58>   jalr    20(ra)                            │
│    0x8000057c <panic+62>   li      a5,1                              │
│    0x8000057e <panic+64>   auipc   a4,0x8                            │
│    0x80000582 <panic+68>   sw      a5,1074(a4)                       │
│  > 0x80000586 <panic+72>   j       0x80000586 <panic+72>             │
│    0x80000588 <printf>     addi    sp,sp,-192                        │
│    0x8000058a <printf+2>   sd      ra,120(sp)                        │
│    0x8000058c <printf+4>   sd      s0,112(sp)                        │
│    0x8000058e <printf+6>   sd      s1,104(sp)                        │
│    0x80000590 <printf+8>   sd      s2,96(sp)                         │
│    0x80000592 <printf+10>  sd      s3,88(sp)                         │
│    0x80000594 <printf+12>  sd      s4,80(sp)                         │
│    0x80000596 <printf+14>  sd      s5,72(sp)                         │
│    0x80000598 <printf+16>  sd      s6,64(sp)                         │
│    0x8000059a <printf+18>  sd      s7,56(sp)                         │
└──────────────────────────────────────────────────────────────────────┘
remote Thread 1.1 In: panic                        L126  PC: 0x80000586
```
